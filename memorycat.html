<!-- ESTE ES EL JUEGO COMPLETO CON LA TABLA DE SEGUIMIENTO Y LA PUNTUACIÓN. -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryCat</title>

    <!-- 
    OBJETIVO: Aplicación de seguimiento de aciertos con estabilidad garantizada.
    - FILAS: Jugadores.
    - COLUMNAS: Preguntas (Carga Híbrida: Firestore si está disponible, si no, estáticas).
    - INTERSECCIÓN: Checkboxes (aciertos/fallos).
    - PERSISTENCIA DE ACIERTOS: La clave es PLAYER_ID-QUESTION_ID (ID estable).
    - PUNTUACIÓN: Se calcula sumando el número de palabras de la respuesta de cada pregunta acertada.
    - PERSISTENCIA: Jugadores y Aciertos usan localStorage.
    -->

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Usamos la fuente Inter */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilos personalizados para los checkboxes */
        .form-checkbox {
            height: 1.5rem;
            width: 1.5rem;
            min-width: 1.5rem; 
            min-height: 1.5rem; 
            cursor: pointer;
            border-radius: 0.25rem;
            border-color: #a0aec0; /* gray-400 */
        }
        .form-checkbox:checked {
             border-color: transparent;
             background-color: #38a169; /* green-600 */
        }
        .table-container {
            width: 100%;
            overflow-x: auto; /* Permite scroll horizontal si la tabla es muy ancha */
        }
        table {
            min-width: 600px; /* Ancho mínimo para forzar el scroll si es necesario */
        }
        /* Estilo para hacer la celda del jugador "sticky" y permitir el scroll horizontal */
        th:first-child {
            position: sticky;
            left: 0;
            z-index: 10;
            background-color: #f9fafb; 
        }
        td:first-child {
            position: sticky;
            left: 0;
            z-index: 5;
            background-color: white; 
            border-right: 1px solid #e2e8f0; /* Separador visual */
        }
        /* Estilos de botones más prominentes */
        .player-button {
            transition: transform 0.1s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .player-button:active {
            transform: translateY(1px);
        }
        /* Ocultar modales por defecto */
        .modal { 
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease; 
        }
        .modal.open { 
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="bg-white p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-6xl">
        
        <!-- Contenedor del Título y el Botón de Ajustes -->
        <div class="flex justify-between items-center mb-6">
            <!-- Botón de Ajustes -->
            <button id="settings-btn" class="text-gray-500 hover:text-gray-700 p-2 rounded-full transition duration-150 ease-in-out" aria-label="Ajustes de Importación y Exportación">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82 1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
            </button>

            <h1 class="text-3xl font-bold text-center text-gray-800 flex-grow">
                MemoryCat (Juego de Aciertos)
            </h1>
            <div class="w-10 h-10"></div> <!-- Placeholder para alinear el título -->
        </div>

        <!-- Indicador de Carga de Preguntas (oculto en modo estático) -->
        <div id="loading-indicator" class="text-center py-4 text-lg font-medium text-blue-600 hidden">
            Intentando cargar preguntas de Firestore...
        </div>
        
        <!-- Mensaje de Cero Preguntas -->
        <div id="no-questions-message" class="text-center py-8 text-xl font-medium text-gray-500 border-2 border-dashed border-gray-300 rounded-lg hidden">
            No hay preguntas cargadas (modo estático).
        </div>

        <!-- TABLA DE SEGUIMIENTO (El corazón de la app) -->
        <div class="table-container rounded-xl border border-gray-300 shadow-lg">
            <table class="w-full text-left">
                <thead class="bg-gray-50 border-b border-gray-300 sticky top-0">
                    <tr>
                        <!-- Cabecera generada por initializeAndRenderHeader() -->
                    </tr>
                </thead>
                <tbody id="player-grid" class="bg-white divide-y divide-gray-200">
                    <!-- Filas de jugadores generadas por renderTable() -->
                </tbody>
            </table>
        </div>
        <!-- FIN DE LA TABLA -->

    </div>

    <!-- Modal (Ficha del Jugador) - Detalles y Puntuación -->
    <div id="player-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" aria-modal="true" role="dialog">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm transform transition-all scale-100" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800">Ficha del Jugador</h2>
                <button id="modal-close" class="text-gray-500 hover:text-gray-800 text-3xl" aria-label="Cerrar">&times;</button>
            </div>
            <div>
                <h3 id="modal-name" class="text-xl font-semibold text-blue-600 mb-2"></h3>
                <p id="modal-course" class="text-gray-700 mb-4"></p>
                <div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded-lg">
                     <p class="font-bold">Puntuación Total:</p>
                     <p id="modal-points" class="text-3xl font-extrabold"></p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal (Ficha de Pregunta) - Incluye el título (no editable), enunciado y puntos -->
    <div id="question-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" aria-modal="true" role="dialog" data-editing-question-id="">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md transform transition-all scale-100" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800">Detalles de Pregunta</h2>
                <button id="modal-q-close" class="text-gray-500 hover:text-gray-800 text-3xl" aria-label="Cerrar">&times;</button>
            </div>
            <div class="space-y-4">
                 <!-- CAMPO DE TÍTULO (SOLO LECTURA) -->
                <div class="bg-blue-50 p-3 rounded-lg border border-blue-200">
                    <h4 class="text-sm font-semibold text-blue-700 uppercase tracking-wider mb-1">Título</h4>
                    <p id="modal-q-title-display" class="w-full text-gray-800 text-xl font-bold"></p>
                </div>
                <!-- FIN CAMPO DE TÍTULO -->

                <div class="bg-gray-50 p-3 rounded-lg border">
                    <h4 class="text-sm font-semibold text-gray-500 uppercase tracking-wider">Enunciado</h4>
                    <p id="modal-q-enunciado" class="text-gray-800 text-lg"></p>
                </div>
                <div class="bg-gray-50 p-3 rounded-lg border">
                    <h4 class="text-sm font-semibold text-gray-500 uppercase tracking-wider">Respuesta Clave</h4>
                    <p id="modal-q-respuesta" class="text-gray-800 text-lg"></p>
                </div>
                <div class="bg-yellow-100 p-3 rounded-lg border border-yellow-300">
                    <h4 class="text-sm font-semibold text-yellow-700 uppercase tracking-wider">Puntos Asignados</h4>
                    <p id="modal-q-puntos" class="text-xl text-yellow-800 font-extrabold"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal (Ajustes: Importar/Exportar) -->
    <div id="settings-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" aria-modal="true" role="dialog">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-lg transform transition-all scale-100" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-gray-800">Importar / Exportar Preguntas</h2>
                <button id="modal-settings-close" class="text-gray-500 hover:text-gray-800 text-3xl" aria-label="Cerrar">&times;</button>
            </div>
            
            <!-- EXPORTAR -->
            <div class="mb-6 border-b pb-4">
                <h3 class="text-xl font-semibold mb-2 text-gray-700">1. Exportar Preguntas Actuales</h3>
                <p class="text-gray-600 text-sm mb-3">Copia las preguntas actuales (ya sean de Firestore o estáticas) como un JSON para guardarlas.</p>
                <button id="export-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150">Copiar JSON de Preguntas</button>
            </div>

            <!-- IMPORTAR -->
            <div class="mb-4">
                <h3 class="text-xl font-semibold mb-2 text-gray-700">2. Importar Preguntas (JSON)</h3>
                <p class="text-sm text-red-600 mb-2">Advertencia: Las preguntas importadas se guardarán en Firestore (si está conectado) y actualizarán la tabla.</p>
                <textarea id="import-json-area" rows="6" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 font-mono text-sm" placeholder='[{"id": "qX", "title": "...", "enunciado": "...", "respuesta": "..."}]'></textarea>
                <button id="import-btn" class="w-full mt-3 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">Importar y Actualizar Firestore</button>
            </div>

            <div id="settings-message" class="mt-4 p-3 rounded-lg text-sm hidden"></div>
        </div>
    </div>


    <script type="module">
        // Importaciones de Firebase (se cargarán solo si __firebase_config existe)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // Añadimos doc y setDoc para la escritura de datos
        import { getFirestore, collection, onSnapshot, setLogLevel, doc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuración y Variables de Firebase (Obligatorias) ---
        // Verificamos si las variables de Firebase existen para determinar el modo de carga
        const hasFirebaseConfig = typeof __firebase_config !== 'undefined' && __firebase_config !== 'null';
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = hasFirebaseConfig ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let userId = null; 
        let isAuthReady = false; 
        
        // --- Datos Estáticos de Reserva ---
        
        // Datos de preguntas de reserva (Fallback)
        const defaultQuestionsData = [
            { id: 'q1', title: 'Q1: CSS Grid', enunciado: 'Explica brevemente qué problema resuelve CSS Grid Layout.', respuesta: 'CSS Grid resuelve el problema de la maquetación bidimensional compleja, permitiendo al desarrollador definir filas y columnas de manera precisa para el diseño de toda una página o componente.', puntos: 25 },
            { id: 'q2', title: 'Q2: Scope JS', enunciado: '¿Cuál es la principal diferencia entre `let` y `var` en JavaScript respecto al scope?', respuesta: 'La principal diferencia es que var tiene un scope de función o global, mientras que let tiene un scope de bloque, limitado a las llaves {} donde es declarado.', puntos: 28 },
            { id: 'q3', title: 'Q3: HTTP Status', enunciado: '¿Qué significa el código de estado HTTP 403?', respuesta: 'El código 403 Forbidden indica que el servidor se niega a autorizar la petición, a pesar de que la sintaxis de la petición es correcta. Esto generalmente se debe a permisos insuficientes o configuración de seguridad.', puntos: 40 },
            { id: 'q4', title: 'Q4: Git Rebase', enunciado: '¿Para qué se utiliza el comando `git rebase`?', respuesta: 'Git rebase se utiliza para integrar cambios de una rama a otra, reescribiendo el historial de commits y haciendo que parezca que los cambios se aplicaron secuencialmente, lo que resulta en un historial de proyecto más limpio y lineal.', puntos: 45 },
            { id: 'q5', title: 'Q5: SPA', enunciado: 'Define el concepto de Single Page Application (SPA).', respuesta: 'Una Single Page Application o SPA es una aplicación web que carga una única página HTML y actualiza dinámicamente el contenido principal mediante JavaScript, sin requerir una recarga completa de la página.', puntos: 30 },
            { id: 'q6', title: 'Q6: NoSQL', enunciado: 'Menciona una ventaja clave de las bases de datos NoSQL sobre las relacionales.', respuesta: 'Una ventaja clave de NoSQL es la escalabilidad horizontal y la flexibilidad del esquema, lo que permite manejar grandes volúmenes de datos no estructurados o semiestructurados y distribuir la carga fácilmente entre múltiples servidores.', puntos: 40 },
        ];

        let questions = defaultQuestionsData; // Inicializamos con las preguntas estáticas
        
        // La fuente de datos de los jugadores (OBJECT). Se queda en localStorage por ahora.
        let players = {
            'player-pepe': { id: 'player-pepe', name: 'Pepe Pérez', course: 'Curso A' },
            'player-juan': { id: 'player-juan', name: 'Juan Jimenez', course: 'Curso B' },
            'player-ana': { id: 'player-ana', name: 'Ana García', course: 'Curso C' }
        };

        // Estado de aciertos guardado como { playerId-questionId: true/false }. Se queda en localStorage por ahora.
        let hitsState = {}; 

        // --- Elementos de UI ---
        const tableHeadRow = document.querySelector('table thead tr');
        const tableBody = document.getElementById('player-grid');
        const playerModal = document.getElementById('player-modal');
        const questionModal = document.getElementById('question-modal');
        const settingsModal = document.getElementById('settings-modal'); 
        const loadingIndicator = document.getElementById('loading-indicator');
        const noQuestionsMessage = document.getElementById('no-questions-message');
        const settingsMessage = document.getElementById('settings-message');

        // --- Utilidades ---
        function countWords(str) {
            if (!str) return 0;
            return str.split(/\s+/).filter(word => word.length > 0).length;
        }

        /** Muestra un mensaje temporal en el modal de ajustes */
        function showSettingsMessage(message, type = 'success') {
            settingsMessage.textContent = message;
            settingsMessage.classList.remove('hidden', 'bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700');
            if (type === 'error') {
                settingsMessage.classList.add('bg-red-100', 'text-red-700');
            } else {
                settingsMessage.classList.add('bg-green-100', 'text-green-700');
            }
            setTimeout(() => {
                settingsMessage.classList.add('hidden');
            }, 5000);
        }

        // --- Persistencia (localStorage para Jugadores y Aciertos) ---
        const HITS_KEY = 'memorycat_hits';
        const PLAYERS_KEY = 'memorycat_players'; 

        /**
         * Guarda el estado de los aciertos y los jugadores en localStorage.
         */
        function saveLocalState() {
            localStorage.setItem(HITS_KEY, JSON.stringify(hitsState));
            localStorage.setItem(PLAYERS_KEY, JSON.stringify(players)); 
        }

        /**
         * Carga el estado de los aciertos y los jugadores desde localStorage.
         */
        function loadLocalState() {
            const storedPlayers = localStorage.getItem(PLAYERS_KEY);
            if (storedPlayers) {
                players = JSON.parse(storedPlayers);
            } 
            
            const storedHits = localStorage.getItem(HITS_KEY);
            if (storedHits) {
                hitsState = JSON.parse(storedHits);
            } else {
                 hitsState = {}; 
            }
            
            saveLocalState();
        }
        
        function getQuestionIdFromHitId(hitId, playerId) {
            if (hitId.startsWith(playerId + '-')) {
                return hitId.substring(playerId.length + 1);
            }
            return null;
        }

        /**
         * Calcula la puntuación total de un jugador.
         */
        function calculatePlayerScore(playerId) {
            const playerHitIds = Object.keys(hitsState).filter(key => key.startsWith(playerId + '-'));
            let score = 0;
            
            playerHitIds.forEach(hitId => {
                if (hitsState[hitId]) { 
                    const questionId = getQuestionIdFromHitId(hitId, playerId); 
                    if (questionId) {
                        const question = questions.find(q => q.id === questionId);
                        const points = question && typeof question.puntos === 'number' ? question.puntos : 0;
                        score += points;
                    }
                }
            });
            return score;
        }

        // --- Renderizado y Lógica de Puntuación ---

        
        /** Muestra un modal */
        function showModal(modalElement) {
            modalElement.classList.add('open');
            modalElement.setAttribute('aria-hidden', 'false');
        }

        /** Oculta un modal */
        function hideModal(modalElement) {
            modalElement.classList.remove('open');
            modalElement.setAttribute('aria-hidden', 'true');
        }
        
        /** Renderiza la cabecera de la tabla */
        function initializeAndRenderHeader() {
            tableHeadRow.innerHTML = '';
            
            let headerHTML = '<th class="px-4 py-3 sm:px-6 text-left text-xs font-semibold text-blue-700 uppercase tracking-wider sticky left-0 bg-gray-50">Jugador / Puntos</th>';
            
            questions.forEach(q => {
                headerHTML += '<th data-question-id="' + q.id + '" class="px-3 py-3 text-center text-xs font-semibold text-blue-700 uppercase tracking-wider cursor-pointer hover:bg-blue-100 transition duration-150 rounded-t-lg">' + q.title + '</th>';
            });

            tableHeadRow.innerHTML = headerHTML;
        }

        /** Renderiza las filas de la tabla (Jugadores y Checkboxes) */
        function renderTable() {
            tableBody.innerHTML = ''; 
            
            if (questions.length === 0) {
                noQuestionsMessage.classList.remove('hidden');
                return;
            } else {
                 noQuestionsMessage.classList.add('hidden');
            }

            Object.values(players).forEach(player => { 
                const tr = document.createElement('tr');
                const initialScore = calculatePlayerScore(player.id);
                
                let rowHTML = `
                    <td class="p-3 sm:p-4 text-md font-medium text-gray-900 sticky left-0 bg-white z-5">
                        <button data-player-id="${player.id}" class="player-button w-full text-left bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-xl transition duration-150 ease-in-out flex justify-between items-center">
                            <span>${player.name}</span>
                            <span id="score-${player.id}" class="bg-white text-blue-600 px-2 py-1 rounded-full text-sm font-extrabold ml-4">${initialScore} Pts</span>
                        </button>
                    </td>`;
                
                questions.forEach(q => {
                    const checkboxId = player.id + '-' + q.id; 
                    const isChecked = hitsState[checkboxId] || false; 

                    rowHTML += `<td class="p-3 sm:p-4 text-center">
                        <input type="checkbox" id="${checkboxId}" data-player-id="${player.id}" data-question-id="${q.id}" class="form-checkbox text-green-500 focus:ring-2 focus:ring-green-400 rounded cursor-pointer" aria-label="${player.name}, pregunta ${q.title}" ${isChecked ? 'checked' : ''}>
                    </td>`;
                });

                tr.innerHTML = rowHTML;
                tableBody.appendChild(tr);
            });
        }
        
        /** Actualiza el elemento SPAN de puntuación para un jugador específico en la tabla. */
        function updatePlayerScoreDisplay(playerId) {
            const score = calculatePlayerScore(playerId);
            const scoreSpan = document.getElementById(`score-${playerId}`);
            if (scoreSpan) {
                scoreSpan.textContent = `${score} Pts`;
            }
            // También actualizamos el modal si está abierto
            const modalName = document.getElementById('modal-name');
            if(playerModal.classList.contains('open') && modalName && modalName.textContent.startsWith(players[playerId].name)) {
                document.getElementById('modal-points').textContent = score; 
            }
        }

        /** Muestra y calcula la puntuación del jugador en el modal. */
        function showPlayerModal(playerId) {
             const player = players[playerId];
             if (!player) return;

             const score = calculatePlayerScore(playerId);
            
            document.getElementById('modal-name').textContent = player.name;
            document.getElementById('modal-course').textContent = 'Curso: ' + player.course;
            document.getElementById('modal-points').textContent = score; 
            showModal(playerModal);
        }

        /** Muestra el modal con los detalles de la pregunta. */
        function showQuestionModal(questionId) {
            const question = questions.find(q => q.id === questionId);
            if (!question) return;

            questionModal.dataset.editingQuestionId = questionId;

            document.getElementById('modal-q-title-display').textContent = question.title;
            document.getElementById('modal-q-enunciado').textContent = question.enunciado || 'N/A';
            document.getElementById('modal-q-respuesta').textContent = question.respuesta || 'N/A';
            document.getElementById('modal-q-puntos').textContent = question.puntos; 
            
            showModal(questionModal);
        }

        // --- Lógica de Firebase y Persistencia Remota ---
        
        /**
         * Guarda una sola pregunta en Firestore.
         * @param {Object} question - La pregunta a guardar.
         */
        async function saveQuestionToFirestore(question) {
            if (!db || !isAuthReady) {
                console.warn("Firestore no está listo. La pregunta no se guardó en la DB.");
                return;
            }

            // Excluir la propiedad 'puntos' ya que es calculada.
            const { puntos, ...dataToSave } = question; 
            
            try {
                const questionDocRef = doc(db, `artifacts/${appId}/public/data/preguntas`, question.id);
                await setDoc(questionDocRef, dataToSave, { merge: true });
                console.log(`Pregunta ${question.id} guardada/actualizada en Firestore.`);
            } catch (error) {
                console.error(`Error al guardar la pregunta ${question.id} en Firestore:`, error);
            }
        }

        /**
         * Configura el listener de Firestore para la colección 'preguntas'.
         */
        function setupQuestionsListener() {
            if (!db || !isAuthReady) return;
            
            const questionsColRef = collection(db, `artifacts/${appId}/public/data/preguntas`);
            loadingIndicator.classList.remove('hidden');
            loadingIndicator.textContent = "Intentando cargar preguntas de Firestore...";


            // onSnapshot: Listener en tiempo real
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const unsubscribe = onSnapshot(questionsColRef, (snapshot) => {
                const fetchedQuestions = [];

                snapshot.forEach(doc => {
                    const data = doc.data();
                    const calculatedPoints = countWords(data.respuesta) > 0 ? countWords(data.respuesta) : 1;

                    fetchedQuestions.push({
                        id: doc.id,
                        title: data.title || doc.id,
                        enunciado: data.enunciado || '',
                        respuesta: data.respuesta || '',
                        puntos: calculatedPoints 
                    });
                });

                if (fetchedQuestions.length > 0) {
                    questions = fetchedQuestions.sort((a, b) => a.title.localeCompare(b.title));
                    loadingIndicator.classList.add('hidden');
                    console.log(`Preguntas de Firestore actualizadas. Total: ${questions.length}`);
                } else {
                    // Si Firestore está vacío, usamos el fallback
                    questions = defaultQuestionsData; 
                    loadingIndicator.classList.add('hidden');
                    console.log("Firestore vacío. Usando preguntas de reserva estáticas.");
                }
                
                // Siempre re-renderizar al recibir datos, incluso si es el fallback
                fullRender();
                
            }, (error) => {
                console.error("Error al escuchar cambios en Firestore. Usando datos estáticos:", error);
                
                // En caso de error (configuración incorrecta, permisos, etc.), usamos el fallback
                questions = defaultQuestionsData; 
                loadingIndicator.classList.add('hidden');
                noQuestionsMessage.classList.remove('hidden');
                noQuestionsMessage.textContent = 'Error de conexión con Firestore. Usando preguntas de reserva.';
                
                // Re-renderizar con los datos estáticos
                fullRender();
                
                // Detener el listener de snapshot para evitar reintentos continuos
                // No llamamos a unsubscribe aquí porque está fuera de su alcance.
                // En un entorno real se manejaría mejor el scope.
                console.warn("Listener de Firestore detenido debido a un error.");
            });
        }
        
        /**
         * Realiza la carga de datos locales y el renderizado.
         * Llamado por el listener de Firestore o directamente si no hay Firebase.
         */
        function fullRender() {
            // Carga jugadores y aciertos de localStorage
            loadLocalState(); 
            
            // Renderiza la interfaz con la lista actual de preguntas (estáticas o de Firestore)
            initializeAndRenderHeader(); 
            renderTable();               
            
            // Actualiza las puntuaciones iniciales
            Object.keys(players).forEach(playerId => updatePlayerScoreDisplay(playerId));
        }

        // --- Lógica de Importación/Exportación ---

        /** Exporta las preguntas actuales a JSON y las copia al portapapeles. */
        function exportQuestions() {
            // Clonamos para eliminar la propiedad 'puntos' que es calculada
            const questionsToExport = questions.map(q => {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { puntos, ...rest } = q;
                return rest;
            });
            const json = JSON.stringify(questionsToExport, null, 2);
            
            // Copiar al portapapeles
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = json;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            
            try {
                document.execCommand('copy');
                showSettingsMessage('Preguntas copiadas al portapapeles como JSON.', 'success');
            } catch (err) {
                showSettingsMessage('Error al copiar: intente seleccionar y copiar el texto manualmente.', 'error');
            }
            document.body.removeChild(tempTextArea);
            
            return json;
        }

        /** Importa preguntas desde JSON, actualiza Firestore y fuerza la recarga. */
        async function importQuestions() {
            const jsonArea = document.getElementById('import-json-area');
            const jsonString = jsonArea.value.trim();

            if (!jsonString) {
                showSettingsMessage('Por favor, pegue el JSON de las preguntas para importar.', 'error');
                return;
            }

            let importedData;
            try {
                importedData = JSON.parse(jsonString);
                if (!Array.isArray(importedData)) throw new Error('El JSON debe ser un array.');
            } catch (e) {
                showSettingsMessage('Error al parsear el JSON: ' + e.message, 'error');
                return;
            }

            let validCount = 0;
            let invalidCount = 0;

            for (const item of importedData) {
                // Validación básica de la estructura
                if (item.id && item.title && item.enunciado && item.respuesta) {
                    if (isAuthReady) {
                        await saveQuestionToFirestore(item); // Guardar en Firestore
                    } else {
                        // Si no está listo, solo lo contamos (no actualizamos la lista local directamente aquí,
                        // ya que la lista local se actualizará con fullRender al final si no hay Firebase)
                    }
                    validCount++;
                } else {
                    invalidCount++;
                }
            }

            if (validCount > 0) {
                // Si la conexión a Firebase está activa, el onSnapshot ya se encargará de
                // actualizar la lista 'questions' y llamar a fullRender().
                if (!isAuthReady) {
                    // Si NO hay Firebase, solo forzamos el renderizado con los datos estáticos de respaldo.
                    // En este modo, la importación JSON es temporal y solo de demostración.
                    // Para un uso persistente sin Firebase, deberíamos sobrescribir 'defaultQuestionsData',
                    // lo cual es una complejidad que evitamos ya que la app DEBE usar Firebase.
                    showSettingsMessage(`Importación de ${validCount} preguntas finalizada. La aplicación está en modo estático, estas preguntas NO se han guardado permanentemente.`, 'error');
                    // Para evitar confusión, limpiamos el área para no reintentar
                    jsonArea.value = '';
                } else {
                     showSettingsMessage(`Importación de ${validCount} preguntas iniciada. Firestore se actualizará en breve...`, 'success');
                     jsonArea.value = '';
                }
            } else {
                showSettingsMessage('No se encontraron preguntas válidas con ID, título, enunciado y respuesta.', 'error');
            }
            
            // Si no hay Firebase, forzamos el renderizado aquí para que el usuario vea los cambios
            if (!isAuthReady && validCount > 0) {
                 // En modo estático, simplemente reemplazamos la lista con las importadas temporalmente
                 questions = importedData.map(item => ({ 
                     ...item, 
                     puntos: countWords(item.respuesta) > 0 ? countWords(item.respuesta) : 1 
                 }));
                 fullRender();
            }
        }


        // --- Inicialización y Event Listeners ---
        window.addEventListener('load', () => {
            
            // 1. Inicialización y Autenticación Híbrida
            if (hasFirebaseConfig) {
                 // Modo Firebase
                 setLogLevel('Debug');
                 app = initializeApp(firebaseConfig);
                 db = getFirestore(app);
                 auth = getAuth(app);
                 
                 loadingIndicator.classList.remove('hidden'); // Mostrar indicador mientras se autentica

                 onAuthStateChanged(auth, async (user) => {
                     if (user) {
                         userId = user.uid;
                         isAuthReady = true;
                         console.log("Firebase Auth successful. User ID:", userId);
                     } else {
                         // Intento de inicio de sesión con token o anónimo
                         try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                            userId = auth.currentUser?.uid || crypto.randomUUID(); // Asegurar ID después de sign in
                            isAuthReady = true;

                         } catch (e) {
                            console.error("Error en signInWithCustomToken/signInAnonymously:", e);
                            isAuthReady = false; // Fallo de autenticación
                         }
                     }
                     
                     // Una vez autenticado (o fallido), iniciamos el listener de preguntas
                     if (isAuthReady) {
                        setupQuestionsListener();
                     } else {
                         // Si la autenticación falla, usamos el fallback directamente
                         questions = defaultQuestionsData;
                         loadingIndicator.classList.add('hidden');
                         noQuestionsMessage.classList.remove('hidden');
                         noQuestionsMessage.textContent = 'Error de autenticación. Usando preguntas de reserva.';
                         fullRender();
                     }
                 });

            } else {
                // Modo Estático (Sin Firebase Config)
                console.warn("Firebase config not available. Running in static mode.");
                isAuthReady = false; 
                loadingIndicator.classList.add('hidden');
                noQuestionsMessage.classList.add('hidden'); // No es necesario si hay preguntas estáticas
                questions = defaultQuestionsData; 
                fullRender();
            }


            // 2. Escucha clics en los checkboxes para guardar el estado Y actualizar la puntuación
            tableBody.addEventListener('change', (event) => {
                if (event.target.type === 'checkbox') {
                    const checkbox = event.target;
                    // El ID del checkbox (playerId-questionId/doc.id) se usa como clave
                    hitsState[checkbox.id] = checkbox.checked; 
                    saveLocalState(); // Guarda el estado localmente
                    
                    // Llama a la función de actualización visual.
                    const playerId = checkbox.dataset.playerId;
                    updatePlayerScoreDisplay(playerId); 
                }
            });

            // 3. Escucha clics en botones de jugador para ver la PUNTUACIÓN (Modal)
            tableBody.addEventListener('click', (event) => {
                const button = event.target.closest('.player-button');
                if (button) showPlayerModal(button.dataset.playerId);
            });

            // 4. Escucha clics en la cabecera para ver detalles de la Pregunta
            tableHeadRow.addEventListener('click', (event) => {
                const header = event.target.closest('th[data-question-id]');
                if (header) showQuestionModal(header.dataset.questionId);
            });
            
            // 5. Listeners para cerrar modales
            document.getElementById('modal-close').addEventListener('click', () => hideModal(playerModal));
            document.getElementById('modal-q-close').addEventListener('click', () => hideModal(questionModal));
            playerModal.addEventListener('click', (e) => {
                 if (e.target === playerModal) hideModal(playerModal);
            });
            questionModal.addEventListener('click', (e) => {
                 if (e.target === questionModal) hideModal(questionModal);
            });
            
            // 6. Listener para el Modal de Ajustes (Importación/Exportación)
            document.getElementById('settings-btn').addEventListener('click', () => showModal(settingsModal));
            document.getElementById('modal-settings-close').addEventListener('click', () => hideModal(settingsModal));
            settingsModal.addEventListener('click', (e) => {
                 if (e.target === settingsModal) hideModal(settingsModal);
            });

            // Conectar botones de I/E
            document.getElementById('export-btn').addEventListener('click', exportQuestions);
            document.getElementById('import-btn').addEventListener('click', importQuestions);
        });

    </script>
</body>
</html>
