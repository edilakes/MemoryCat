<!-- ESTE ES EL JUEGO COMPLETO CON LA TABLA DE SEGUIMIENTO Y LA PUNTUACIÓN. -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemCat</title>

    <!-- 
    OBJETIVO: Aplicación de seguimiento de aciertos con estabilidad garantizada.
    - FILAS: Jugadores.
    - COLUMNAS: Preguntas (etiquetadas con su campo 'title').
    - INTERSECCIÓN: Checkboxes (aciertos/fallos).
    - PERSISTENCIA DE ACIERTOS: La clave es PLAYER_ID-QUESTION_ID (UUID/ID estable), lo que garantiza la persistencia aunque las preguntas se reordenen.
    - PUNTUACIÓN: Se calcula sumando el número de palabras de la respuesta de cada pregunta acertada.
    - PERSISTENCIA: Los datos se guardan en el navegador (localStorage) para este ejemplo.
    -->

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Usamos la fuente Inter */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilos personalizados para los checkboxes */
        .form-checkbox {
            height: 1.5rem;
            width: 1.5rem;
            min-width: 1.5rem; 
            min-height: 1.5rem; 
            cursor: pointer;
            border-radius: 0.25rem;
            border-color: #a0aec0; /* gray-400 */
        }
        .form-checkbox:checked {
             border-color: transparent;
             background-color: #38a169; /* green-600 */
        }
        .table-container {
            width: 100%;
            overflow-x: auto; /* Permite scroll horizontal si la tabla es muy ancha */
        }
        table {
            min-width: 600px; /* Ancho mínimo para forzar el scroll si es necesario */
        }
        /* Estilo para hacer la celda del jugador "sticky" y permitir el scroll horizontal */
        th:first-child {
            position: sticky;
            left: 0;
            z-index: 10;
            background-color: #f9fafb; 
        }
        td:first-child {
            position: sticky;
            left: 0;
            z-index: 5;
            background-color: white; 
            border-right: 1px solid #e2e8f0; /* Separador visual */
        }
        /* Estilos de botones más prominentes */
        .player-button {
            transition: transform 0.1s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .player-button:active {
            transform: translateY(1px);
        }
        /* Ocultar modales por defecto */
        .modal { 
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease; 
        }
        .modal.open { 
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="bg-white p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-6xl">
        
        <!-- Contenedor del Título y el Botón de Ajustes (Versión anterior) -->
        <div class="flex justify-between items-center mb-6">
            <!-- Botón de Ajustes (simplificado: solo para info de la app) -->
            <button id="settings-btn" class="text-gray-500 hover:text-gray-700 p-2 rounded-full transition duration-150 ease-in-out" aria-label="Ajustes y Opciones">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </button>

            <h1 class="text-3xl font-bold text-center text-gray-800 flex-grow">
                MemCat (Juego de Aciertos)
            </h1>
            <div class="w-10 h-10"></div> <!-- Placeholder para alinear el título -->
        </div>


        <!-- TABLA DE SEGUIMIENTO (El corazón de la app) -->
        <div class="table-container rounded-xl border border-gray-300 shadow-lg">
            <table class="w-full text-left">
                <thead class="bg-gray-50 border-b border-gray-300 sticky top-0">
                    <tr>
                        <!-- Cabecera generada por initializeAndRenderHeader() -->
                    </tr>
                </thead>
                <tbody id="player-grid" class="bg-white divide-y divide-gray-200">
                    <!-- Filas de jugadores generadas por renderTable() -->
                </tbody>
            </table>
        </div>
        <!-- FIN DE LA TABLA -->

    </div>

    <!-- Modal (Ficha del Jugador) - Aquí se muestra la PUNTUACIÓN (sigue siendo útil para ver detalles) -->
    <div id="player-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" aria-modal="true" role="dialog">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm transform transition-all scale-100" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800">Ficha del Jugador</h2>
                <button id="modal-close" class="text-gray-500 hover:text-gray-800 text-3xl" aria-label="Cerrar">&times;</button>
            </div>
            <div>
                <h3 id="modal-name" class="text-xl font-semibold text-blue-600 mb-2"></h3>
                <p id="modal-course" class="text-gray-700 mb-4"></p>
                <div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded-lg">
                     <p class="font-bold">Puntuación Total:</p>
                     <p id="modal-points" class="text-3xl font-extrabold"></p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal (Ficha de Pregunta) - Incluye el título (no editable), enunciado y puntos -->
    <div id="question-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" aria-modal="true" role="dialog" data-editing-question-id="">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md transform transition-all scale-100" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800">Detalles de Pregunta</h2>
                <button id="modal-q-close" class="text-gray-500 hover:text-gray-800 text-3xl" aria-label="Cerrar">&times;</button>
            </div>
            <div class="space-y-4">
                 <!-- CAMPO DE TÍTULO (AHORA DE SOLO LECTURA) -->
                <div class="bg-blue-50 p-3 rounded-lg border border-blue-200">
                    <h4 class="text-sm font-semibold text-blue-700 uppercase tracking-wider mb-1">Título</h4>
                    <!-- Se ha cambiado el INPUT por un P para hacerlo de solo lectura -->
                    <p id="modal-q-title-display" class="w-full text-gray-800 text-xl font-bold"></p>
                </div>
                <!-- FIN CAMPO DE TÍTULO -->

                <div class="bg-gray-50 p-3 rounded-lg border">
                    <h4 class="text-sm font-semibold text-gray-500 uppercase tracking-wider">Enunciado</h4>
                    <p id="modal-q-enunciado" class="text-gray-800 text-lg"></p>
                </div>
                <div class="bg-gray-50 p-3 rounded-lg border">
                    <h4 class="text-sm font-semibold text-gray-500 uppercase tracking-wider">Respuesta Clave</h4>
                    <p id="modal-q-respuesta" class="text-gray-800 text-lg"></p>
                </div>
                <div class="bg-yellow-100 p-3 rounded-lg border border-yellow-300">
                    <h4 class="text-sm font-semibold text-yellow-700 uppercase tracking-wider">Puntos Asignados</h4>
                    <p id="modal-q-puntos" class="text-xl text-yellow-800 font-extrabold"></p>
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        // La implementación actual utiliza localStorage para persistencia.
        // Las importaciones de Firebase se mantienen para futuras integraciones.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuración y Variables de Firebase (Obligatorias) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let userId = null;
        
        // --- Utilidades ---

        /**
         * Genera un identificador único (UUID v4)
         */
        function generateUUID() {
            return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        /**
         * Cuenta las palabras en una cadena de texto para asignar puntos. 
         * @param {string} str La cadena de texto (la respuesta).
         * @returns {number} El número de palabras.
         */
        function countWords(str) {
            if (!str) return 0;
            // Usa una expresión regular para dividir por espacios y filtrar cadenas vacías
            return str.split(/\s+/).filter(word => word.length > 0).length;
        }

        // --- Variables Globales y Estado ---
        
        // La fuente de datos de las preguntas (ARRAY). El campo 'id' DEBE ser un UUID o un ID estable.
        let initialQuestionsData = [
            { 
                id: generateUUID(), // UUID para las preguntas reales
                title: 'Mandamientos', 
                enunciado: '¿Cuántos son los Mandamientos de la ley de Dios?', 
                respuesta: 'Los Mandamientos de la Ley de Dios son diez', // 6 palabras = 6 puntos
            },
             { 
                id: generateUUID(), // UUID para las preguntas reales
                title: 'Penitencia', 
                enunciado: '¿Cuál es el sacramento de la penitencia?', 
                respuesta: 'La confesión es el sacramento de la penitencia.' // 5 palabras = 5 puntos
            },
            {
                id: generateUUID(), // UUID para las preguntas reales
                title: 'Pecado Original', 
                enunciado: '¿Qué es el pecado original?', 
                respuesta: 'El pecado original es aquel con el que nacemos todos' // 8 palabras = 8 puntos
            }
        ];

        // La lista completa de preguntas con los puntos y títulos calculados
        // ATENCIÓN: Esta lista es la que se modifica al editar el título.
        let questions = []; 

        // La fuente de datos de los jugadores (OBJECT). Con IDs estables.
        let players = {
            'player-pepe': { id: 'player-pepe', name: 'Pepe Pérez', course: 'Curso A' },
            'player-juan': { id: 'player-juan', name: 'Juan Jimenez', course: 'Curso B' },
            'player-ana': { id: 'player-ana', name: 'Ana García', course: 'Curso C' }
        };

        // Estado de aciertos guardado como { playerId-questionId: true/false }
        let hitsState = {}; 

        // --- Persistencia (localStorage) ---
        const HITS_KEY = 'memcat_hits';
        // CLAVE ADICIONAL para guardar la lista de preguntas
        const QUESTIONS_KEY = 'memcat_questions'; 

        /**
         * Guarda el estado de los aciertos y las preguntas.
         */
        function saveState() {
            localStorage.setItem(HITS_KEY, JSON.stringify(hitsState));
            localStorage.setItem(QUESTIONS_KEY, JSON.stringify(questions)); // Guarda la estructura actual de preguntas
        }

        /**
         * Carga el estado de los aciertos y las preguntas.
         */
        function loadState() {
            // Carga el estado de los aciertos
            const storedHits = localStorage.getItem(HITS_KEY);
            if (storedHits) {
                hitsState = JSON.parse(storedHits);
            } else {
                 hitsState = {}; // Si no hay hits, inicializa vacío
            }
            
            // Carga la estructura de las preguntas si existe
            const storedQuestions = localStorage.getItem(QUESTIONS_KEY);
            if (storedQuestions) {
                // Si hay preguntas guardadas, las usamos
                questions = JSON.parse(storedQuestions);
            } else {
                // Si no hay preguntas guardadas, inicializamos la estructura completa
                 initializeData();
            }


            // Aplica el estado de aciertos a los checkboxes (se hace en fullRender/renderTable)
        }
        
        /**
         * Inicializa la estructura de datos de las preguntas, garantizando 23 preguntas.
         * Se llama solo si no hay datos de preguntas en localStorage.
         */
        function initializeData() {
            // Número fijo de preguntas a generar (23 para llenar la tabla)
            const maxQuestions = 23;
            questions = [];
            
            const defaultPlaceholderPoints = 1; 

            for (let i = 0; i < maxQuestions; i++) {
                // Usamos la pregunta inicial si existe
                const existingQuestion = initialQuestionsData.find((q, index) => index === i); 
                let q = existingQuestion ? {...existingQuestion} : {}; // Clonamos para no modificar la fuente original

                // Si no existe, creamos un placeholder con ID estable y título numérico.
                if (!existingQuestion) {
                     // ID estable para el placeholder basado en su índice
                     const stablePlaceholderId = 'placeholder-q-' + (i + 1); 
                     
                     q.id = stablePlaceholderId;
                     q.title = 'Q-' + (i + 1);
                     q.enunciado = 'Pregunta de Relleno ' + (i + 1);
                     q.respuesta = 'Respuesta corta.';
                } 
                
                // CALCULO CLAVE: Los puntos son el número de palabras en la respuesta.
                const calculatedPoints = countWords(q.respuesta) > 0 ? countWords(q.respuesta) : defaultPlaceholderPoints;

                // Generación de la estructura final
                questions.push({
                    ...q,
                    puntos: calculatedPoints // Asignamos los puntos calculados
                });
            }
            // Guardamos el estado inicial de las preguntas al crear la estructura
            saveState(); 
        }

        /**
         * Obtiene la ID de la pregunta a partir de la ID del acierto (que tiene el formato playerId-questionId).
         * @param {string} hitId La clave del acierto (ej: 'player-pepe-uuid1234')
         * @param {string} playerId El ID del jugador (ej: 'player-pepe')
         * @returns {string | null} La ID de la pregunta (ej: 'uuid1234')
         */
        function getQuestionIdFromHitId(hitId, playerId) {
            // El ID de la pregunta es lo que queda después del ID del jugador y el guión.
            if (hitId.startsWith(playerId + '-')) {
                return hitId.substring(playerId.length + 1);
            }
            return null;
        }

        /**
         * Calcula la puntuación total de un jugador.
         * @param {string} playerId 
         * @returns {number} Puntuación total.
         */
        function calculatePlayerScore(playerId) {
            // Filtra todos los IDs de aciertos que comienzan con el ID del jugador
            // La clave de acierto YA usa el ID único/UUID de la pregunta.
            const playerHitIds = Object.keys(hitsState).filter(key => key.startsWith(playerId + '-'));
            let score = 0;
            
            // Lógica de Puntuación: SUMA LOS PUNTOS DE LAS PREGUNTAS ACERTADAS
            playerHitIds.forEach(hitId => {
                // Solo suma si la casilla está marcada como acertada (true)
                if (hitsState[hitId]) { 
                    
                    const questionId = getQuestionIdFromHitId(hitId, playerId); 
                    
                    if (questionId) {
                        // Buscamos la pregunta por su ID (UUID/ID estable) para obtener sus puntos
                        const question = questions.find(q => q.id === questionId);

                        // Si la pregunta existe y tiene puntos, los suma.
                        const points = question && typeof question.puntos === 'number' ? question.puntos : 0;
                        score += points;
                    }
                }
            });
            return score;
        }

        // --- Renderizado y Lógica de Puntuación ---

        const tableHeadRow = document.querySelector('table thead tr');
        const tableBody = document.getElementById('player-grid');
        const playerModal = document.getElementById('player-modal');
        const questionModal = document.getElementById('question-modal');
        // Usamos el nuevo ID para el elemento P de solo lectura
        const questionTitleDisplay = document.getElementById('modal-q-title-display'); 
        
        // La función de edición se mantiene, pero ya no se usa el listener del change del input.
        function updateQuestionTitle() { /* NO HAY NADA QUE HACER */ }

        /**
         * Muestra un modal
         */
        function showModal(modalElement) {
            modalElement.classList.add('open');
            modalElement.setAttribute('aria-hidden', 'false');
        }

        /**
         * Oculta un modal
         */
        function hideModal(modalElement) {
            modalElement.classList.remove('open');
            modalElement.setAttribute('aria-hidden', 'true');
        }

        /**
         * Renderiza la cabecera de la tabla (Jugador | Título 1 | Título 2...)
         */
        function initializeAndRenderHeader() {
            tableHeadRow.innerHTML = '';
            
            // Primera columna: Jugador / Puntos (Sticky)
            let headerHTML = '<th class="px-4 py-3 sm:px-6 text-left text-xs font-semibold text-blue-700 uppercase tracking-wider sticky left-0 bg-gray-50">Jugador / Puntos</th>';
            
            // Columnas de preguntas (usando el campo 'title' de cada pregunta)
            questions.forEach(q => {
                // Usamos q.title para la cabecera
                headerHTML += '<th data-question-id="' + q.id + '" class="px-3 py-3 text-center text-xs font-semibold text-blue-700 uppercase tracking-wider cursor-pointer hover:bg-blue-100 transition duration-150 rounded-t-lg">' + q.title + '</th>';
            });

            tableHeadRow.innerHTML = headerHTML;
        }

        /**
         * Renderiza las filas de la tabla (Jugadores y Checkboxes)
         */
        function renderTable() {
            tableBody.innerHTML = ''; 

            Object.values(players).forEach(player => {
                const tr = document.createElement('tr');
                
                // Celda del jugador: Ahora muestra el nombre Y la puntuación en un span
                const initialScore = calculatePlayerScore(player.id);
                
                let rowHTML = `
                    <td class="p-3 sm:p-4 text-md font-medium text-gray-900 sticky left-0 bg-white z-5">
                        <!-- Botón que muestra el modal de detalles del jugador -->
                        <button data-player-id="${player.id}" class="player-button w-full text-left bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-xl transition duration-150 ease-in-out flex justify-between items-center">
                            <span>${player.name}</span>
                            <!-- Span para la puntuación en tiempo real -->
                            <span id="score-${player.id}" class="bg-white text-blue-600 px-2 py-1 rounded-full text-sm font-extrabold ml-4">${initialScore} Pts</span>
                        </button>
                    </td>`;
                
                // Celdas de checkboxes (seguimiento de aciertos)
                questions.forEach(q => {
                    // CLAVE DE PERSISTENCIA: player.id - q.id (UUID o ID estable)
                    const checkboxId = player.id + '-' + q.id; 
                    const isChecked = hitsState[checkboxId] || false; // Carga el estado del acierto

                    rowHTML += `<td class="p-3 sm:p-4 text-center">
                        <input type="checkbox" id="${checkboxId}" data-player-id="${player.id}" data-question-id="${q.id}" class="form-checkbox text-green-500 focus:ring-2 focus:ring-green-400 rounded cursor-pointer" aria-label="${player.name}, pregunta ${q.title}" ${isChecked ? 'checked' : ''}>
                    </td>`;
                });

                tr.innerHTML = rowHTML;
                tableBody.appendChild(tr);
            });
        }
        
        /**
         * Actualiza el elemento SPAN de puntuación para un jugador específico en la tabla.
         * @param {string} playerId 
         */
        function updatePlayerScoreDisplay(playerId) {
            const score = calculatePlayerScore(playerId);
            const scoreSpan = document.getElementById(`score-${playerId}`);
            if (scoreSpan) {
                scoreSpan.textContent = `${score} Pts`;
            }
            // También actualizamos el modal si está abierto
            const modalName = document.getElementById('modal-name');
            // Nota: Se asume que players[playerId].name es el inicio del texto en modalName
            if(playerModal.classList.contains('open') && modalName && modalName.textContent.startsWith(players[playerId].name)) {
                document.getElementById('modal-points').textContent = score; 
            }
        }


        /**
         * Muestra y calcula la puntuación del jugador en el modal. 
         */
        function showPlayerModal(playerId) {
             const player = players[playerId];
             if (!player) return;

             const score = calculatePlayerScore(playerId);
            
            // Poblar y mostrar modal
            const modalName = document.getElementById('modal-name');
            const modalCourse = document.getElementById('modal-course');
            const modalPoints = document.getElementById('modal-points');

            modalName.textContent = player.name;
            modalCourse.textContent = 'Curso: ' + player.course;
            modalPoints.textContent = score; // Muestra la PUNTUACIÓN
            showModal(playerModal);
        }

        /**
         * Muestra el modal con los detalles de la pregunta.
         */
        function showQuestionModal(questionId) {
            const question = questions.find(q => q.id === questionId);
            if (!question) return;

            // Almacena el ID de la pregunta (aunque no sea editable, es buena práctica)
            questionModal.dataset.editingQuestionId = questionId;

            // Se ha modificado para usar el elemento P de solo lectura
            questionTitleDisplay.textContent = question.title;

            // Cargar el resto de la información
            document.getElementById('modal-q-enunciado').textContent = question.enunciado;
            document.getElementById('modal-q-respuesta').textContent = question.respuesta;
            document.getElementById('modal-q-puntos').textContent = question.puntos; 
            
            showModal(questionModal);
        }

        /**
         * Inicializa la aplicación: carga estado (o inicializa), renderiza.
         */
        function fullRender() {
            // Carga o inicializa los datos de preguntas y aciertos.
            loadState(); 
            
            // Renderiza la interfaz
            initializeAndRenderHeader(); 
            renderTable();               
            
            // Después de cargar el estado y renderizar, actualizamos todas las puntuaciones visibles
            Object.keys(players).forEach(playerId => updatePlayerScoreDisplay(playerId));
        }

        // --- Inicialización y Event Listeners ---
        window.addEventListener('load', () => {
            // Inicializar Firebase (aunque no se use db/auth/userId, el setup es obligatorio)
             if (firebaseConfig) {
                 app = initializeApp(firebaseConfig);
                 db = getFirestore(app);
                 auth = getAuth(app);

                 // Autenticación obligatoria
                 const signIn = initialAuthToken 
                    ? signInWithCustomToken(auth, initialAuthToken)
                    : signInAnonymously(auth);

                 signIn.then(userCredential => {
                     userId = userCredential.user.uid;
                     console.log("Firebase Auth successful. User ID:", userId);
                     // Continuar con la carga de la aplicación después de la autenticación
                     fullRender();
                 }).catch(error => {
                     console.error("Firebase Auth failed:", error);
                     // Si la autenticación falla, se ejecuta fullRender con datos locales
                     fullRender();
                 });

            } else {
                console.warn("Firebase config not available. Running in local mode.");
                fullRender();
            }

            // 1. Escucha clics en los checkboxes para guardar el estado Y actualizar la puntuación
            tableBody.addEventListener('change', (event) => {
                if (event.target.type === 'checkbox') {
                    const checkbox = event.target;
                    // El ID del checkbox (playerId-questionId/UUID) se usa como clave
                    hitsState[checkbox.id] = checkbox.checked; 
                    saveState(); // Guarda el estado en localStorage
                    
                    // LLAMADA CLAVE: Llama a la función de actualización visual.
                    const playerId = checkbox.dataset.playerId;
                    updatePlayerScoreDisplay(playerId); 
                }
            });

            // 2. Escucha clics en botones de jugador para ver la PUNTUACIÓN (Modal)
            tableBody.addEventListener('click', (event) => {
                const button = event.target.closest('.player-button');
                if (button) showPlayerModal(button.dataset.playerId);
            });

            // 3. Escucha clics en la cabecera para ver detalles de la Pregunta
            // Delegamos el evento en la fila de la cabecera
            tableHeadRow.addEventListener('click', (event) => {
                const header = event.target.closest('th[data-question-id]');
                if (header) showQuestionModal(header.dataset.questionId);
            });
            
            // 4. Se eliminó el listener para la edición del título.

            // 5. Listeners para cerrar modales
            document.getElementById('modal-close').addEventListener('click', () => hideModal(playerModal));
            document.getElementById('modal-q-close').addEventListener('click', () => hideModal(questionModal));
            playerModal.addEventListener('click', (e) => {
                 if (e.target === playerModal) hideModal(playerModal);
            });
            questionModal.addEventListener('click', (e) => {
                 if (e.target === questionModal) hideModal(questionModal);
            });
        });

    </script>
</body>
</html>
