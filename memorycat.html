<!-- ESTE ES EL JUEGO COMPLETO CON LA TABLA DE SEGUIMIENTO Y LA PUNTUACIÓN. -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemCat</title>

    <!-- 
    OBJETIVO: Aplicación de seguimiento de aciertos con estabilidad garantizada.
    - FILAS: Jugadores.
    - COLUMNAS: Preguntas (etiquetadas con su campo 'title').
    - INTERSECCIÓN: Checkboxes (aciertos/fallos).
    - PERSISTENCIA DE ACIERTOS: La clave es PLAYER_ID-QUESTION_ID (UUID/ID estable), lo que garantiza la persistencia aunque las preguntas se reordenen.
    - PUNTUACIÓN: Se calcula sumando el número de palabras de la respuesta de cada pregunta acertada.
    - PERSISTENCIA: Los datos se guardan en el navegador (localStorage) para este ejemplo.
    -->

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Usamos la fuente Inter */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilos personalizados para los checkboxes */
        .form-checkbox {
            height: 1.5rem;
            width: 1.5rem;
            min-width: 1.5rem; 
            min-height: 1.5rem; 
            cursor: pointer;
            border-radius: 0.25rem;
            border-color: #a0aec0; /* gray-400 */
        }
        .form-checkbox:checked {
             border-color: transparent;
             background-color: #38a169; /* green-600 */
        }
        .table-container {
            width: 100%;
            overflow-x: auto; /* Permite scroll horizontal si la tabla es muy ancha */
        }
        table {
            min-width: 600px; /* Ancho mínimo para forzar el scroll si es necesario */
        }
        /* Estilo para hacer la celda del jugador "sticky" y permitir el scroll horizontal */
        th:first-child {
            position: sticky;
            left: 0;
            z-index: 10;
            background-color: #f9fafb; 
        }
        td:first-child {
            position: sticky;
            left: 0;
            z-index: 5;
            background-color: white; 
            border-right: 1px solid #e2e8f0; /* Separador visual */
        }
        /* Estilos de botones más prominentes */
        .player-button {
            transition: transform 0.1s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .player-button:active {
            transform: translateY(1px);
        }
        /* Ocultar modales por defecto */
        .modal { 
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease; 
        }
        .modal.open { 
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="bg-white p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-6xl">
        
        <!-- Contenedor del Título y el Botón de Ajustes -->
        <div class="flex justify-between items-center mb-6">
            <!-- Botón de Ajustes (AHORA ABRE EL MODAL DE IMPORTAR/EXPORTAR) -->
            <button id="settings-btn" class="text-gray-500 hover:text-gray-700 p-2 rounded-full transition duration-150 ease-in-out" aria-label="Ajustes de Importación y Exportación">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82 1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
            </button>

            <h1 class="text-3xl font-bold text-center text-gray-800 flex-grow">
                MemCat (Juego de Aciertos)
            </h1>
            <div class="w-10 h-10"></div> <!-- Placeholder para alinear el título -->
        </div>


        <!-- TABLA DE SEGUIMIENTO (El corazón de la app) -->
        <div class="table-container rounded-xl border border-gray-300 shadow-lg">
            <table class="w-full text-left">
                <thead class="bg-gray-50 border-b border-gray-300 sticky top-0">
                    <tr>
                        <!-- Cabecera generada por initializeAndRenderHeader() -->
                    </tr>
                </thead>
                <tbody id="player-grid" class="bg-white divide-y divide-gray-200">
                    <!-- Filas de jugadores generadas por renderTable() -->
                </tbody>
            </table>
        </div>
        <!-- FIN DE LA TABLA -->

    </div>

    <!-- Modal (Ficha del Jugador) - Detalles y Puntuación -->
    <div id="player-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" aria-modal="true" role="dialog">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm transform transition-all scale-100" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800">Ficha del Jugador</h2>
                <button id="modal-close" class="text-gray-500 hover:text-gray-800 text-3xl" aria-label="Cerrar">&times;</button>
            </div>
            <div>
                <h3 id="modal-name" class="text-xl font-semibold text-blue-600 mb-2"></h3>
                <p id="modal-course" class="text-gray-700 mb-4"></p>
                <div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded-lg">
                     <p class="font-bold">Puntuación Total:</p>
                     <p id="modal-points" class="text-3xl font-extrabold"></p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal (Ficha de Pregunta) - Incluye el título (no editable), enunciado y puntos -->
    <div id="question-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" aria-modal="true" role="dialog" data-editing-question-id="">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md transform transition-all scale-100" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800">Detalles de Pregunta</h2>
                <button id="modal-q-close" class="text-gray-500 hover:text-gray-800 text-3xl" aria-label="Cerrar">&times;</button>
            </div>
            <div class="space-y-4">
                 <!-- CAMPO DE TÍTULO (AHORA DE SOLO LECTURA) -->
                <div class="bg-blue-50 p-3 rounded-lg border border-blue-200">
                    <h4 class="text-sm font-semibold text-blue-700 uppercase tracking-wider mb-1">Título</h4>
                    <!-- Se ha cambiado el INPUT por un P para hacerlo de solo lectura -->
                    <p id="modal-q-title-display" class="w-full text-gray-800 text-xl font-bold"></p>
                </div>
                <!-- FIN CAMPO DE TÍTULO -->

                <div class="bg-gray-50 p-3 rounded-lg border">
                    <h4 class="text-sm font-semibold text-gray-500 uppercase tracking-wider">Enunciado</h4>
                    <p id="modal-q-enunciado" class="text-gray-800 text-lg"></p>
                </div>
                <div class="bg-gray-50 p-3 rounded-lg border">
                    <h4 class="text-sm font-semibold text-gray-500 uppercase tracking-wider">Respuesta Clave</h4>
                    <p id="modal-q-respuesta" class="text-gray-800 text-lg"></p>
                </div>
                <div class="bg-yellow-100 p-3 rounded-lg border border-yellow-300">
                    <h4 class="text-sm font-semibold text-yellow-700 uppercase tracking-wider">Puntos Asignados</h4>
                    <p id="modal-q-puntos" class="text-xl text-yellow-800 font-extrabold"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- NUEVO: Modal (Ajustes: Importar/Exportar) -->
    <div id="settings-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" aria-modal="true" role="dialog">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-lg transform transition-all scale-100" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-gray-800">Importar / Exportar Datos</h2>
                <button id="modal-settings-close" class="text-gray-500 hover:text-gray-800 text-3xl" aria-label="Cerrar">&times;</button>
            </div>
            
            <p class="text-gray-600 mb-6">Selecciona el tipo de datos para importar o exportar en formato JSON.</p>

            <!-- Contenedor para Jugadores -->
            <div class="mb-5 p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
                <h3 class="text-lg font-semibold text-indigo-800 mb-3">1. Jugadores</h3>
                <div class="flex flex-col sm:flex-row gap-3">
                    <button id="export-players-btn" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                        Exportar Jugadores
                    </button>
                    <!-- Input de archivo oculto para Importar Jugadores -->
                    <label for="import-players-file" class="flex-1 text-center bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg cursor-pointer transition duration-150">
                        Importar Jugadores (JSON)
                        <input type="file" id="import-players-file" class="hidden" accept=".json" data-collection-key="players">
                    </label>
                </div>
            </div>

            <!-- Contenedor para Preguntas -->
            <div class="mb-5 p-4 bg-green-50 border border-green-200 rounded-lg">
                <h3 class="text-lg font-semibold text-green-800 mb-3">2. Preguntas</h3>
                <div class="flex flex-col sm:flex-row gap-3">
                    <button id="export-questions-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                        Exportar Preguntas
                    </button>
                    <!-- Input de archivo oculto para Importar Preguntas -->
                    <label for="import-questions-file" class="flex-1 text-center bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg cursor-pointer transition duration-150">
                        Importar Preguntas (JSON)
                        <input type="file" id="import-questions-file" class="hidden" accept=".json" data-collection-key="questions">
                    </label>
                </div>
            </div>

            <!-- Contenedor para Aciertos (Hits) -->
            <div class="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                <h3 class="text-lg font-semibold text-yellow-800 mb-3">3. Aciertos</h3>
                <div class="flex flex-col sm:flex-row gap-3">
                    <button id="export-hits-btn" class="flex-1 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150">
                        Exportar Aciertos
                    </button>
                    <!-- Input de archivo oculto para Importar Aciertos -->
                    <label for="import-hits-file" class="flex-1 text-center bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg cursor-pointer transition duration-150">
                        Importar Aciertos (JSON)
                        <input type="file" id="import-hits-file" class="hidden" accept=".json" data-collection-key="hits">
                    </label>
                </div>
            </div>

            <div id="import-message" class="mt-4 text-center text-sm font-medium hidden"></div>
        </div>
    </div>


    <script type="module">
        // La implementación actual utiliza localStorage para persistencia.
        // Las importaciones de Firebase se mantienen para futuras integraciones.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuración y Variables de Firebase (Obligatorias) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let userId = null;
        
        // --- Utilidades ---

        /**
         * Genera un identificador único (UUID v4)
         */
        function generateUUID() {
            return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        /**
         * Cuenta las palabras en una cadena de texto para asignar puntos. 
         * @param {string} str La cadena de texto (la respuesta).
         * @returns {number} El número de palabras.
         */
        function countWords(str) {
            if (!str) return 0;
            // Usa una expresión regular para dividir por espacios y filtrar cadenas vacías
            return str.split(/\s+/).filter(word => word.length > 0).length;
        }

        // --- Variables Globales y Estado ---
        
        // La fuente de datos de las preguntas (ARRAY). El campo 'id' DEBE ser un UUID o un ID estable.
        let initialQuestionsData = [
            { 
                id: generateUUID(), // UUID para las preguntas reales
                title: 'Mandamientos', 
                enunciado: '¿Cuántos son los Mandamientos de la ley de Dios?', 
                respuesta: 'Los Mandamientos de la Ley de Dios son diez', // 6 palabras = 6 puntos
            },
             { 
                id: generateUUID(), // UUID para las preguntas reales
                title: 'Penitencia', 
                enunciado: '¿Cuál es el sacramento de la penitencia?', 
                respuesta: 'La confesión es el sacramento de la penitencia.' // 5 palabras = 5 puntos
            },
            {
                id: generateUUID(), // UUID para las preguntas reales
                title: 'Pecado Original', 
                enunciado: '¿Qué es el pecado original?', 
                respuesta: 'El pecado original es aquel con el que nacemos todos' // 8 palabras = 8 puntos
            }
        ];

        // La lista completa de preguntas con los puntos y títulos calculados
        let questions = []; 

        // La fuente de datos de los jugadores (OBJECT). Con IDs estables.
        let players = {
            'player-pepe': { id: 'player-pepe', name: 'Pepe Pérez', course: 'Curso A' },
            'player-juan': { id: 'player-juan', name: 'Juan Jimenez', course: 'Curso B' },
            'player-ana': { id: 'player-ana', name: 'Ana García', course: 'Curso C' }
        };

        // Estado de aciertos guardado como { playerId-questionId: true/false }
        let hitsState = {}; 

        // --- Persistencia (localStorage) ---
        const HITS_KEY = 'memcat_hits';
        // CLAVE ADICIONAL para guardar la lista de preguntas
        const QUESTIONS_KEY = 'memcat_questions'; 
        // CLAVE NUEVA para guardar la lista de jugadores
        const PLAYERS_KEY = 'memcat_players'; 

        /**
         * Guarda el estado de los aciertos, las preguntas, y los jugadores.
         */
        function saveState() {
            localStorage.setItem(HITS_KEY, JSON.stringify(hitsState));
            localStorage.setItem(QUESTIONS_KEY, JSON.stringify(questions)); 
            localStorage.setItem(PLAYERS_KEY, JSON.stringify(players)); // Guarda el objeto de jugadores
        }

        /**
         * Carga el estado de los aciertos, las preguntas, y los jugadores.
         */
        function loadState() {
            // 1. Carga Jugadores
            const storedPlayers = localStorage.getItem(PLAYERS_KEY);
            if (storedPlayers) {
                players = JSON.parse(storedPlayers);
            } 
            
            // 2. Carga Preguntas
            const storedQuestions = localStorage.getItem(QUESTIONS_KEY);
            if (storedQuestions) {
                questions = JSON.parse(storedQuestions);
            } else {
                // Si no hay preguntas guardadas, inicializamos la estructura completa.
                // initializeData() llama a saveState(), guardando todo (incluidos los jugadores por defecto).
                 initializeData();
                 return;
            }

            // 3. Carga el estado de los aciertos
            const storedHits = localStorage.getItem(HITS_KEY);
            if (storedHits) {
                hitsState = JSON.parse(storedHits);
            } else {
                 hitsState = {}; // Si no hay hits, inicializa vacío
            }
            
            // Si llegamos aquí y no se llamó a initializeData, guardamos el estado 
            // (Esto asegura que los jugadores por defecto se persistan si las preguntas ya existían).
            saveState();
        }
        
        /**
         * Inicializa la estructura de datos de las preguntas, garantizando 23 preguntas.
         * Se llama solo si no hay datos de preguntas en localStorage.
         */
        function initializeData() {
            // Número fijo de preguntas a generar (23 para llenar la tabla)
            const maxQuestions = 23;
            questions = [];
            
            const defaultPlaceholderPoints = 1; 

            for (let i = 0; i < maxQuestions; i++) {
                // Usamos la pregunta inicial si existe
                const existingQuestion = initialQuestionsData.find((q, index) => index === i); 
                let q = existingQuestion ? {...existingQuestion} : {}; // Clonamos para no modificar la fuente original

                // Si no existe, creamos un placeholder con ID estable y título numérico.
                if (!existingQuestion) {
                     // ID estable para el placeholder basado en su índice
                     const stablePlaceholderId = 'placeholder-q-' + (i + 1); 
                     
                     q.id = stablePlaceholderId;
                     q.title = 'Q-' + (i + 1);
                     q.enunciado = 'Pregunta de Relleno ' + (i + 1);
                     q.respuesta = 'Respuesta corta.';
                } 
                
                // CALCULO CLAVE: Los puntos son el número de palabras en la respuesta.
                const calculatedPoints = countWords(q.respuesta) > 0 ? countWords(q.respuesta) : defaultPlaceholderPoints;

                // Generación de la estructura final
                questions.push({
                    ...q,
                    puntos: calculatedPoints // Asignamos los puntos calculados
                });
            }
            // Guardamos el estado inicial de las preguntas, jugadores y hits (vacío)
            saveState(); 
        }

        /**
         * Obtiene la ID de la pregunta a partir de la ID del acierto (que tiene el formato playerId-questionId).
         */
        function getQuestionIdFromHitId(hitId, playerId) {
            // El ID de la pregunta es lo que queda después del ID del jugador y el guión.
            if (hitId.startsWith(playerId + '-')) {
                return hitId.substring(playerId.length + 1);
            }
            return null;
        }

        /**
         * Calcula la puntuación total de un jugador.
         * @param {string} playerId 
         * @returns {number} Puntuación total.
         */
        function calculatePlayerScore(playerId) {
            // Filtra todos los IDs de aciertos que comienzan con el ID del jugador
            const playerHitIds = Object.keys(hitsState).filter(key => key.startsWith(playerId + '-'));
            let score = 0;
            
            playerHitIds.forEach(hitId => {
                // Solo suma si la casilla está marcada como acertada (true)
                if (hitsState[hitId]) { 
                    
                    const questionId = getQuestionIdFromHitId(hitId, playerId); 
                    
                    if (questionId) {
                        // Buscamos la pregunta por su ID (UUID/ID estable) para obtener sus puntos
                        const question = questions.find(q => q.id === questionId);

                        // Si la pregunta existe y tiene puntos, los suma.
                        const points = question && typeof question.puntos === 'number' ? question.puntos : 0;
                        score += points;
                    }
                }
            });
            return score;
        }

        // --- Renderizado y Lógica de Puntuación ---

        const tableHeadRow = document.querySelector('table thead tr');
        const tableBody = document.getElementById('player-grid');
        const playerModal = document.getElementById('player-modal');
        const questionModal = document.getElementById('question-modal');
        const settingsModal = document.getElementById('settings-modal'); // NUEVO
        const questionTitleDisplay = document.getElementById('modal-q-title-display'); 
        const importMessage = document.getElementById('import-message'); // Mensaje de feedback

        
        /**
         * Muestra un modal
         */
        function showModal(modalElement) {
            modalElement.classList.add('open');
            modalElement.setAttribute('aria-hidden', 'false');
        }

        /**
         * Oculta un modal
         */
        function hideModal(modalElement) {
            modalElement.classList.remove('open');
            modalElement.setAttribute('aria-hidden', 'true');
        }
        
        /**
         * Muestra un mensaje de éxito o error en el modal de importación/exportación.
         */
        function showImportMessage(message, isError = true) {
            importMessage.textContent = message;
            importMessage.classList.remove('hidden', 'text-red-600', 'text-green-600');
            importMessage.classList.add(isError ? 'text-red-600' : 'text-green-600');
            setTimeout(() => {
                importMessage.classList.add('hidden');
            }, 5000);
        }

        /**
         * Renderiza la cabecera de la tabla (Jugador | Título 1 | Título 2...)
         */
        function initializeAndRenderHeader() {
            tableHeadRow.innerHTML = '';
            
            // Primera columna: Jugador / Puntos (Sticky)
            let headerHTML = '<th class="px-4 py-3 sm:px-6 text-left text-xs font-semibold text-blue-700 uppercase tracking-wider sticky left-0 bg-gray-50">Jugador / Puntos</th>';
            
            // Columnas de preguntas (usando el campo 'title' de cada pregunta)
            questions.forEach(q => {
                // Usamos q.title para la cabecera
                headerHTML += '<th data-question-id="' + q.id + '" class="px-3 py-3 text-center text-xs font-semibold text-blue-700 uppercase tracking-wider cursor-pointer hover:bg-blue-100 transition duration-150 rounded-t-lg">' + q.title + '</th>';
            });

            tableHeadRow.innerHTML = headerHTML;
        }

        /**
         * Renderiza las filas de la tabla (Jugadores y Checkboxes)
         */
        function renderTable() {
            tableBody.innerHTML = ''; 
            
            // Aseguramos que players sea un array de valores (aunque se almacene como objeto)
            Object.values(players).forEach(player => { 
                const tr = document.createElement('tr');
                
                // Celda del jugador: Ahora muestra el nombre Y la puntuación en un span
                const initialScore = calculatePlayerScore(player.id);
                
                let rowHTML = `
                    <td class="p-3 sm:p-4 text-md font-medium text-gray-900 sticky left-0 bg-white z-5">
                        <!-- Botón que muestra el modal de detalles del jugador -->
                        <button data-player-id="${player.id}" class="player-button w-full text-left bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-xl transition duration-150 ease-in-out flex justify-between items-center">
                            <span>${player.name}</span>
                            <!-- Span para la puntuación en tiempo real -->
                            <span id="score-${player.id}" class="bg-white text-blue-600 px-2 py-1 rounded-full text-sm font-extrabold ml-4">${initialScore} Pts</span>
                        </button>
                    </td>`;
                
                // Celdas de checkboxes (seguimiento de aciertos)
                questions.forEach(q => {
                    // CLAVE DE PERSISTENCIA: player.id - q.id (UUID o ID estable)
                    const checkboxId = player.id + '-' + q.id; 
                    const isChecked = hitsState[checkboxId] || false; // Carga el estado del acierto

                    rowHTML += `<td class="p-3 sm:p-4 text-center">
                        <input type="checkbox" id="${checkboxId}" data-player-id="${player.id}" data-question-id="${q.id}" class="form-checkbox text-green-500 focus:ring-2 focus:ring-green-400 rounded cursor-pointer" aria-label="${player.name}, pregunta ${q.title}" ${isChecked ? 'checked' : ''}>
                    </td>`;
                });

                tr.innerHTML = rowHTML;
                tableBody.appendChild(tr);
            });
        }
        
        /**
         * Actualiza el elemento SPAN de puntuación para un jugador específico en la tabla.
         * @param {string} playerId 
         */
        function updatePlayerScoreDisplay(playerId) {
            const score = calculatePlayerScore(playerId);
            const scoreSpan = document.getElementById(`score-${playerId}`);
            if (scoreSpan) {
                scoreSpan.textContent = `${score} Pts`;
            }
            // También actualizamos el modal si está abierto
            const modalName = document.getElementById('modal-name');
            // Nota: Se asume que players[playerId].name es el inicio del texto en modalName
            if(playerModal.classList.contains('open') && modalName && modalName.textContent.startsWith(players[playerId].name)) {
                document.getElementById('modal-points').textContent = score; 
            }
        }


        /**
         * Muestra y calcula la puntuación del jugador en el modal. 
         */
        function showPlayerModal(playerId) {
             const player = players[playerId];
             if (!player) return;

             const score = calculatePlayerScore(playerId);
            
            // Poblar y mostrar modal
            const modalName = document.getElementById('modal-name');
            const modalCourse = document.getElementById('modal-course');
            const modalPoints = document.getElementById('modal-points');

            modalName.textContent = player.name;
            modalCourse.textContent = 'Curso: ' + player.course;
            modalPoints.textContent = score; // Muestra la PUNTUACIÓN
            showModal(playerModal);
        }

        /**
         * Muestra el modal con los detalles de la pregunta.
         */
        function showQuestionModal(questionId) {
            const question = questions.find(q => q.id === questionId);
            if (!question) return;

            // Almacena el ID de la pregunta (aunque no sea editable, es buena práctica)
            questionModal.dataset.editingQuestionId = questionId;

            // Se ha modificado para usar el elemento P de solo lectura
            questionTitleDisplay.textContent = question.title;

            // Cargar el resto de la información
            document.getElementById('modal-q-enunciado').textContent = question.enunciado;
            document.getElementById('modal-q-respuesta').textContent = question.respuesta;
            document.getElementById('modal-q-puntos').textContent = question.puntos; 
            
            showModal(questionModal);
        }
        
        // --- Lógica de Importación/Exportación ---

        /**
         * Exporta datos JSON a un archivo descargable.
         * @param {object} data Objeto o Array a exportar.
         * @param {string} filename Nombre del archivo.
         */
        function exportData(data, filename) {
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Crear un enlace temporal para la descarga
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Limpiar URL del objeto
            
            showImportMessage(`Datos de ${filename.replace('memcat_', '').replace('.json', '')} exportados con éxito.`, false);
        }

        /**
         * Importa datos JSON desde un archivo y actualiza la colección.
         * @param {Event} event Evento de cambio del input de archivo.
         * @param {string} collectionKey Clave de la colección ('players', 'questions', 'hits').
         */
        function importData(event, collectionKey) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);

                    if (collectionKey === 'players') {
                        if (typeof importedData !== 'object' || Array.isArray(importedData)) {
                            throw new Error('El archivo de Jugadores debe ser un objeto.');
                        }
                        players = importedData;
                        saveState();
                        fullRender(); // Re-renderizar todo
                        showImportMessage('Jugadores importados y guardados con éxito.', false);

                    } else if (collectionKey === 'questions') {
                         if (!Array.isArray(importedData)) {
                            throw new Error('El archivo de Preguntas debe ser un array.');
                        }
                        // Recalcular puntos para las preguntas importadas (garantizar consistencia)
                        questions = importedData.map(q => ({
                            ...q,
                            puntos: countWords(q.respuesta) > 0 ? countWords(q.respuesta) : 1
                        }));
                        saveState();
                        fullRender(); // Re-renderizar todo
                        showImportMessage('Preguntas importadas y guardadas con éxito.', false);
                        
                    } else if (collectionKey === 'hits') {
                        if (typeof importedData !== 'object' || Array.isArray(importedData)) {
                            throw new Error('El archivo de Aciertos debe ser un objeto.');
                        }
                        hitsState = importedData;
                        saveState();
                        // Actualizar la vista sin recrear la estructura de players/questions
                        initializeAndRenderHeader(); 
                        renderTable(); 
                        Object.keys(players).forEach(playerId => updatePlayerScoreDisplay(playerId)); 
                        showImportMessage('Aciertos importados y guardados con éxito.', false);

                    }

                    // Limpiar el input file para permitir la misma importación de nuevo
                    event.target.value = ''; 

                } catch (error) {
                    console.error("Error al importar datos:", error);
                    showImportMessage('ERROR: El archivo no es un JSON válido o tiene un formato incorrecto.', true);
                    event.target.value = ''; // Limpiar el input file
                }
            };

            reader.readAsText(file);
        }
        // --- FIN Lógica de Importación/Exportación ---


        /**
         * Inicializa la aplicación: carga estado (o inicializa), renderiza.
         */
        function fullRender() {
            // Carga o inicializa los datos de preguntas, jugadores y aciertos.
            loadState(); 
            
            // Renderiza la interfaz
            initializeAndRenderHeader(); 
            renderTable();               
            
            // Después de cargar el estado y renderizar, actualizamos todas las puntuaciones visibles
            Object.keys(players).forEach(playerId => updatePlayerScoreDisplay(playerId));
        }

        // --- Inicialización y Event Listeners ---
        window.addEventListener('load', () => {
            // Inicializar Firebase (aunque no se use db/auth/userId, el setup es obligatorio)
             if (firebaseConfig) {
                 app = initializeApp(firebaseConfig);
                 db = getFirestore(app);
                 auth = getAuth(app);

                 // Autenticación obligatoria
                 const signIn = initialAuthToken 
                    ? signInWithCustomToken(auth, initialAuthToken)
                    : signInAnonymously(auth);

                 signIn.then(userCredential => {
                     userId = userCredential.user.uid;
                     console.log("Firebase Auth successful. User ID:", userId);
                     // Continuar con la carga de la aplicación después de la autenticación
                     fullRender();
                 }).catch(error => {
                     console.error("Firebase Auth failed:", error);
                     // Si la autenticación falla, se ejecuta fullRender con datos locales
                     fullRender();
                 });

            } else {
                console.warn("Firebase config not available. Running in local mode.");
                fullRender();
            }

            // 1. Escucha clics en los checkboxes para guardar el estado Y actualizar la puntuación
            tableBody.addEventListener('change', (event) => {
                if (event.target.type === 'checkbox') {
                    const checkbox = event.target;
                    // El ID del checkbox (playerId-questionId/UUID) se usa como clave
                    hitsState[checkbox.id] = checkbox.checked; 
                    saveState(); // Guarda el estado en localStorage
                    
                    // LLAMADA CLAVE: Llama a la función de actualización visual.
                    const playerId = checkbox.dataset.playerId;
                    updatePlayerScoreDisplay(playerId); 
                }
            });

            // 2. Escucha clics en botones de jugador para ver la PUNTUACIÓN (Modal)
            tableBody.addEventListener('click', (event) => {
                const button = event.target.closest('.player-button');
                if (button) showPlayerModal(button.dataset.playerId);
            });

            // 3. Escucha clics en la cabecera para ver detalles de la Pregunta
            tableHeadRow.addEventListener('click', (event) => {
                const header = event.target.closest('th[data-question-id]');
                if (header) showQuestionModal(header.dataset.questionId);
            });
            
            // 4. Listeners para cerrar modales (Jugador y Pregunta)
            document.getElementById('modal-close').addEventListener('click', () => hideModal(playerModal));
            document.getElementById('modal-q-close').addEventListener('click', () => hideModal(questionModal));
            playerModal.addEventListener('click', (e) => {
                 if (e.target === playerModal) hideModal(playerModal);
            });
            questionModal.addEventListener('click', (e) => {
                 if (e.target === questionModal) hideModal(questionModal);
            });
            
            // 5. NUEVOS Listeners para el Modal de Ajustes (Importar/Exportar)
            document.getElementById('settings-btn').addEventListener('click', () => showModal(settingsModal));
            document.getElementById('modal-settings-close').addEventListener('click', () => hideModal(settingsModal));
            settingsModal.addEventListener('click', (e) => {
                 if (e.target === settingsModal) hideModal(settingsModal);
            });

            // Listeners de Exportación
            document.getElementById('export-players-btn').addEventListener('click', () => exportData(players, 'memcat_jugadores.json'));
            document.getElementById('export-questions-btn').addEventListener('click', () => exportData(questions, 'memcat_preguntas.json'));
            document.getElementById('export-hits-btn').addEventListener('click', () => exportData(hitsState, 'memcat_aciertos.json'));

            // Listeners de Importación
            document.getElementById('import-players-file').addEventListener('change', (e) => importData(e, 'players'));
            document.getElementById('import-questions-file').addEventListener('change', (e) => importData(e, 'questions'));
            document.getElementById('import-hits-file').addEventListener('change', (e) => importData(e, 'hits'));
        });

    </script>
</body>
</html>
